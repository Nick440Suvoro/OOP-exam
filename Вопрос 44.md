# Вопрос 44
**Какими функциями могут быть конструктор и деструктор (статическим и нестатическим методом класса, дружественной функцией, виртуальной функцией)? Почему? Аргументируйте ответ.**

Для ответа на данный вопрос для начала следует дать следующие определения:

### СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ МЕТОДЫ КЛАССА.

Помимо переменных-членов статическими можно объявлять и функции-члены, но обычно это не делается. Доступ к объявленной статической функции — члену класса возможен только для других статических членов этого класса. У статической функции-члена нет указателя `this`. Статические функции-члены не могут быть виртуальными. Статические функции-члены не могут объявляться с идентификаторами `const` (постоянный) и `volatile` (переменный). И наконец, статические функции — члены класса могут вызываться любым объектом этого класса, а также через имя класса и оператор расширения области видимости без всякой связи с каким бы то ни было объектом этого класса.

Однако статические методы могут оказаться удобными для предварительной опеределения статических атрибутов до создания экземпляров или просто независимо от доступа к ним.

В C++ статические члены класса не инициализируются с помощью конструктора, поскольку они не зависят от инициализации объекта, хотя в некоторых языках программирования есть возможность инициализировать статические поля через статический конструктор. 

* **Дружественные функции** -
  Это такие функции, которые **имеют** доступ к `private` и `protected` полям класса. Не являются членами класса. Инициализируются в классе с помощью ключевого слова `friend`. 
  
* **Виртуальные функции** - 
  Это такие функции, которые могут быть переопределены в классах-наследниках так, что конкректная реализация метода вызова будет определяться во время исполнения (Run-time). Обозначаются ключевым словом `virtual`

**Исходя из всего вышеперечисленного, можно сделать выводы о следующем:** 

* Конструктор - это функция-член класса, имя которой совпадает с именем класса. Это помогает инициализировать объект класса. Он может либо принимать аргументы, либо нет. Он используется для выделения памяти объекту класса. Он вызывается всякий раз, когда создается экземпляр класса. Он может быть определен вручную с аргументами или без аргументов. В классе может быть много конструкторов. Он может быть перегружен, но не может быть унаследованным или виртуальным. Существует концепция конструктора копирования, который используется для инициализации объекта из другого объекта.

* Конструктор и деструктор не могут быть **дружественными** функциями, так как их нельзя переопределить и инициализировать вне класса. 
* Деструктор может быть **виртуальным**. Нужен для того, чтобы не происходило утечек памяти и вызывался нужный деструктор. (см. вопрос 7)

* Конструктор и деструктор являются **нестатическими** по умолчанию.

Разница между конструктором и деструктором в C ++ : 

| N |                        Конструктор                     |                        Деструктор |
|--|-------------|---------|
| 1. | 	Конструктор помогает инициализировать объект класса. |	В то время как деструктор используется для уничтожения экземпляров. |
| 2. |	Он объявляется как className(аргументы, если есть){Тело конструктора}. |	Тогда как он объявлен как ~ className(без аргументов){ }. |
| 3. |	Конструктор может либо принимать аргументы, либо нет.	| Хотя у него не может быть никаких аргументов. |
| 4. |	Конструктор вызывается при создании экземпляра или объекта класса. |	Он вызывается, когда объект класса освобождается или удаляется. |
| 5. |	Конструктор используется для выделения памяти экземпляру или объекту.	| В то время как он используется для освобождения памяти объекта класса. |
| 2. |	Конструктор может быть перегружен. |	Пока он не может быть перегружен.
| 3. |	Имя конструктора совпадает с именем класса.	| Здесь его имя также совпадает с именем класса, которому предшествует оператор tiled (~). |
| 4. |	В классе может быть несколько конструкторов. | В классе всегда есть один деструктор.
| 5. |	Существует концепция конструктора копирования, который используется для инициализации объекта из другого объекта. |	В то время как здесь нет концепции конструктора копирования. |
| 6. |	Они часто вызываются в последовательном порядке. |	Они часто вызываются в порядке, обратном конструктору. |