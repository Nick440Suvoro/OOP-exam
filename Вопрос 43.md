# Вопрос 43
**Конструктор и деструктор: назначение, решаемые задачи, взаимодействие с средствами выделения памяти.**

**Конструктор** – это функция, которая работает в момент создания объекта класса.
* Конструктор имеет то же имя, что и класс
* Конструктор не имеет типа 

[//]: <> (Как функция может иметь тип??)

* Конструктор ничего не возвращает, он настраивает значения полей и выделяет память под динамические массивы, которые используются в объекте.
* Чаще всего, конструкторы относятся к открытой зоне (public). 

[//]: <> (Почему конструкторы и деструкторы не объявляют в private??)

При этом, зачастую конструкторов много для того, чтобы можно было в разных ситуациях давать разные наборы значений для атрибутов класса. Для того, чтобы этого добиться, применяется перегрузка функций.
  
Важное действие, которое производится в конструкторе, - это выделение памяти под динамические массивы, если они присутствуют в качестве атрибута класса.

Например, для класса строка `BaseString`, где

- `p` – указатель на первый элемент массива `char`
- `len` – количество заполненных элементов 
- `capacity` – объём выделенной памяти  

необходимо выделить память под массив `p`. В примере представлено два конструктора: конструктор с одним параметром и конструктор копий. 

```c++
class BaseString
{
private:
    char* p;
    int len;
    int capacity;
public:
    BaseString(char* ptr)
    {
        len = strlen(ptr) + 1;
        capacity = 256;
        p = new char[capacity];
        for(int i=0;i<len;i++)
        {
            p[i] = ptr[i];
        }
        p[len] = '\0';
    }
    BaseString(int Capacity = 256)
    {
        capacity = Capacity;
        p = new char[capacity];
        len = 0;
    }
//…
}
```

**Деструктор** - это функция, которя служит для освобождения выделенной конструктором под объект класса памяти и удаления самого объекта класса.

* Имеет то же имя, что и класс.
* Чтобы отличать деструктор от конструкторов, в названии
используют тильду `~`.
* Деструктор может быть только один – он не перегружается и не
принимает параметров. Так делается потому, что обычно он вызывается автоматически.

[//]: <> ("обычно он вызывается автоматически", а есть ли такие ситуация, когда мы вынуждены сами вызвать деструктор в ручную?)

Важно понимать, что деструктор класса вызывается для всех объектов имееющих тип класса (за исключением ссылок или указателей).


Например, деструктор класса `BaseString`, приведённого выше как пример, работает следующим образом:

```c++
class BaseString
{
protected:
    char* p;
    int len;
    int capacity;
public:
//…
    ~BaseString()
    {
        if(p!=NULL)
            delete[] p;
        len = 0;
    }
};
```