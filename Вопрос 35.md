# Вопрос 35
**Как автоматически обнаруживать потери динамической памяти?**

_Утечка памяти происходит, когда динамическая память, которая уже
использована в программе и далее не нужна, не освобождается._ 

Утечки – существенная проблема для процессов, которые должны работать в системе долго (и требуют памяти в течение длительного времени). 

* Оперативная память (ОЗУ) —  память, часть системы
памяти ЭВМ, в которую процессор может обратиться за одну
операцию. Предназначена для временного хранения данных и
команд, необходимых процессору для выполнения им операций.
Оперативная память передает процессору данные
непосредственно, либо через кеш-память.

* Каждая ячейка оперативной памяти имеет свой
индивидуальный адрес

* Динамическое выделение памяти может происходить, например, в конструкторе копий, после выхода из этого конструктора память очищена не будет - деструктор не сработает

* Следует выделять и освобождать память в одном и том же модуле.


# Автоматический поиск утечки

Существует методика нахождения утечек при помощи библиотеки **CRT** 
```c++
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
```

* Оператор #define сопоставляет базовые версии функций кучи CRT соответствующим отладочным версиям. Если оператор #define не используется, дамп утечки памяти будет менее подробным.

* Включение файла crtdbg.h сопоставляет функции malloc и free с их отладочными версиями, _malloc_dbg и _free_dbg, которые отслеживают выделение и освобождение памяти. Это сопоставление используется только в отладочных построениях, в которых определен _DEBUG. В окончательных построениях используются первоначальные функции malloc и free .

* После того как с помощью этих операторов будут включены отладочные функции кучи, можно поместить вызов _CrtDumpMemoryLeaks перед точкой выхода приложения для отображения отчета об утечке памяти перед завершением работы приложения.
``` c++
_CrtDumpMemoryLeaks();
```
* Если приложение имеет несколько выходов, вам не нужно вручную размещать _CrtDumpMemoryLeaks в каждой точке выхода. Для автоматического вызова _CrtDumpMemoryLeaks в каждой точке выхода поместите вызов _CrtSetDbgFlag в начале приложения с помощью следующих битовых полей:
  
``` c++
_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
```
* По умолчанию _CrtDumpMemoryLeaks выводит отчет об утечке памяти в область Отладка окна Вывод . Если используется библиотека, она может переустановить вывод в другое расположение.

* _CrtSetReportMode можно использовать для перенаправления отчета в другое расположение или обратно в окно вывода, как показано ниже:

```c++
_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );
```

# Интерпретация отчета об утечке памяти

* Если приложение не определяет _CRTDBG_MAP_ALLOC, _CrtDumpMemoryLeaks отображает отчет об утечке памяти, аналогичный следующему:

```cmd
Detected memory leaks!
Dumping objects ->
{18} normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```
* Если приложение определяет _CRTDBG_MAP_ALLOC, отчет об утечке памяти выглядит следующим образом:

```cmd
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\leaktest\leaktest.cpp(20) : {18}
normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```

* Во втором отчете отображается имя файла и номер строки, в которой впервые было произведено выделение утекающей памяти.

**Общий вид вывода сообщения об ошибке:**

* Номер выделения памяти, в этом примере — 18.
* Тип блока, в примере — normal.
* Расположение памяти в шестнадцатеричном формате, в этом примере — 0x00780E80.
* Размер блока, в этом примере — 64 bytes.
* Первые 16 байт данных в блоке, в шестнадцатеричном формате.

# Примечания:

* Блок CRT — это блок памяти, выделенной библиотекой CRT для внутреннего использования. Библиотека CRT обрабатывает освобождение этих блоков, поэтому CRT-блоки не будут отображаться в отчете об утечке памяти, если нет серьезных проблем с библиотекой CRT.
* Предыдущие способы выявляют утечки памяти для памяти, выделенной с помощью стандартной функции malloc библиотеки CRT. Однако если программа выделяет память с использованием оператора new C++, то в отчете об утечке памяти вы увидите только имя файла и номер строки, где operator new вызывает _malloc_dbg. 
* Чтобы создать более полезный отчет об утечке памяти, можно написать макрос следующего вида, и в отчете будет указываться строка, в которой было выполнено выделение:

```c++
#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif
```

Теперь можно заменить оператор new с помощью макроса DBG_NEW в коде. 
В отладочных сборках **DBG_NEW** использует перегрузку глобальных operator **new**, которая принимает дополнительные параметры для типа блока, файла и номера строки. 
Перегрузка **new** вызывает **_malloc_dbg** для записи дополнительных сведений. Отчеты об утечке памяти показывают имя файла и номер строки, в которой были выделены утечки объектов. Сборки выпуска по-прежнему используют **new** по умолчанию. 
Вот пример этого метода:

```c++
// debug_new.cpp
// compile by using: cl /EHsc /W4 /D_DEBUG /MDd debug_new.cpp
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>

#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif

struct Pod {
    int x;
};

void main() {
    Pod* pPod = DBG_NEW Pod;
    pPod = DBG_NEW Pod; // Oops, leaked the original pPod!
    delete pPod;

    _CrtDumpMemoryLeaks();
}
```
```cmd
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\debug_new\debug_new.cpp(20) : {75}
 normal block at 0x0098B8C8, 4 bytes long.
 Data: <    > CD CD CD CD
Object dump complete.
```
